---
title: "R-面向对象编程"
author: 王诗翔
date: 2018-08-15
slug: "high-level-OOP"
categories: 
    - R
tags:
    - class
    - instance
    - S3
    - S4
---



<blockquote>
<p>内容：</p>
<ul>
<li>S3</li>
<li>S4</li>
<li>引用类（Reference class, RC）</li>
<li>R6扩展包</li>
</ul>
</blockquote>
<p><strong>借助面向对象的编码风格，并加以合理的抽象，我们可以简单地模仿对象的重要特性，于是，问题和模型之间的转换就变得清晰自然</strong>。</p>
<div id="s3" class="section level2">
<h2>S3对象</h2>
<p><strong>S3对象系统是一个简单且宽松的面向对象系统</strong>。每个基本对象的类型都有一个S3类名称。比如<code>integer</code>,<code>numeric</code>, <code>character</code>, <code>logical</code>, <code>list</code>和<code>data.frame</code>都属于S3类。</p>
<p>举例，下面<code>vec1</code>类型是<code>double</code>，意味其内部类型或者说存储模式是双精度浮点型数字。但它的类是<code>numeric</code>。</p>
<pre class="r"><code>vec1 = c(1, 2, 3)
typeof(vec1)
#&gt; [1] &quot;double&quot;
class(vec1)
#&gt; [1] &quot;numeric&quot;</code></pre>
<p>下面<code>data1</code>类型是<code>list</code>，意味<code>data1</code>的内部类型或者存储模式是列表，但它的S3类是<code>data.frame</code>。</p>
<pre class="r"><code>data1 = data.frame(x = 1:3, y = rnorm(3))

typeof(data1)
#&gt; [1] &quot;list&quot;

class(data1)
#&gt; [1] &quot;data.frame&quot;</code></pre>
<p>理解对象的<strong>内部类型</strong>与<strong>S3类</strong>区别是一个重点。</p>
<p>一个类可以用多种方法定义它的行为，尤其是它与其他类的关系。在S3系统中，我们可以创建<strong>泛型函数（generic function）</strong>，对于不同的类，由泛型函数决定调用哪个方法，这就是<strong>S3方法分派（method dispatch）</strong>的工作机理。</p>
<p>对象的类不同，其方法分派不同，因此，区别对象的类十分重要。</p>
<p>R中有许多基于某个通用目的定义的S3泛型函数，我们先看看<code>head()</code>与<code>tail()</code>。<code>head()</code>展示一个数据对象的前n条记录，<code>tail()</code>展示后n条。这跟<code>x[1:n]</code>是不同的，因为对不同的类的对象，记录的定义是不同的。对原子向量（数值、字符向量等），前n条记录指前n个元素。但对于数据框，前n条记录指前n行而不是前n列。</p>
<p>查看下<code>head</code>的函数内部信息：</p>
<pre class="r"><code>head
#&gt; function (x, ...) 
#&gt; UseMethod(&quot;head&quot;)
#&gt; &lt;bytecode: 0x0000000018fbb138&gt;
#&gt; &lt;environment: namespace:utils&gt;</code></pre>
<p>我们发现函数中并没有实际的操作细节。它调用<code>UseMethod(&quot;head&quot;)</code>来让<strong>泛型函数</strong><code>head()</code>执行方法分派，也就是说，对于不同的类，它可能有不同的执行方式（过程）。</p>
<pre class="r"><code>num_vec = c(1, 2, 3, 4, 5)
data_frame = data.frame(x = 1:5, y = rnorm(5))</code></pre>
<p>调用函数：</p>
<pre class="r"><code>head(num_vec, 3)
#&gt; [1] 1 2 3
head(data_frame, 3)
#&gt;   x      y
#&gt; 1 1 -0.249
#&gt; 2 2 -0.881
#&gt; 3 3  0.781</code></pre>
<p>我们可以使用<code>methods()</code>查看<code>head()</code>函数可以实现的所有方法：</p>
<pre class="r"><code>methods(&quot;head&quot;)
#&gt; [1] head.data.frame* head.default*    head.ftable*     head.function*  
#&gt; [5] head.matrix      head.table*     
#&gt; see &#39;?methods&#39; for accessing help and source code</code></pre>
<p>可以看到<code>head</code>不仅仅适用于向量和数据框。</p>
<p><strong>注意</strong>，方法都是以<code>method.class</code>形式表示，如果我们输入一个<code>data.frame</code>，<code>head()</code>会调用<code>head.data.frame</code>方法。当没有方法可以匹配对象的类时，函数会自动转向<code>method.default</code>方法。这就是<strong>方法分派</strong>的一个实际过程。</p>
<div class="section level3">
<h3>内置类和方法</h3>
<p><strong>S3泛型函数和方法在统一各个模型的使用方式上是最有用的</strong>。比如我们可以创建一个线性模型，以不同角度查看模型信息：</p>
<pre class="r"><code>lm1 = lm(mpg ~ cyl + vs, data = mtcars)</code></pre>
<p><strong>线性模型本质上是由模型拟合产生的数据字段构成的列表</strong>，所以<code>lm1</code>的类型是<code>list</code>，但是它的类是<code>lm</code>，因此泛型函数根据<code>lm</code>选择方法：</p>
<pre class="r"><code>typeof(lm1)
#&gt; [1] &quot;list&quot;

class(lm1)
#&gt; [1] &quot;lm&quot;</code></pre>
<p>甚至没有明确调用S3泛型函数时，S3方法分派也会自动进行。如果我们输入<code>lm1</code>：</p>
<pre class="r"><code>lm1
#&gt; 
#&gt; Call:
#&gt; lm(formula = mpg ~ cyl + vs, data = mtcars)
#&gt; 
#&gt; Coefficients:
#&gt; (Intercept)          cyl           vs  
#&gt;      39.625       -3.091       -0.939</code></pre>
<p>实际上，<code>print()</code>函数被默默地调用了：</p>
<pre class="r"><code>print(lm1)
#&gt; 
#&gt; Call:
#&gt; lm(formula = mpg ~ cyl + vs, data = mtcars)
#&gt; 
#&gt; Coefficients:
#&gt; (Intercept)          cyl           vs  
#&gt;      39.625       -3.091       -0.939</code></pre>
<p>为什么打印出来的不像列表呢？因为<code>print()</code>是一个泛型函数，它为<code>lm</code>选择了一个方法来打印线性模型最重要的信息。我们可以调用<code>getS3method(&quot;print&quot;, &quot;lm&quot;)</code>获取实际使用的方法与想象的进行验证：</p>
<pre class="r"><code>identical(getS3method(&quot;print&quot;, &quot;lm&quot;), stats:::print.lm)
#&gt; [1] TRUE</code></pre>
<p><code>print()</code>展示模型的一个简要版本，<code>summary()</code>展示更详细的信息。<code>summary()</code>也是一个泛型函数，它为模型的所有类提供了许多方法：</p>
<pre class="r"><code>summary(lm1)
#&gt; 
#&gt; Call:
#&gt; lm(formula = mpg ~ cyl + vs, data = mtcars)
#&gt; 
#&gt; Residuals:
#&gt;    Min     1Q Median     3Q    Max 
#&gt; -4.923 -1.953 -0.081  1.319  7.577 
#&gt; 
#&gt; Coefficients:
#&gt;             Estimate Std. Error t value Pr(&gt;|t|)    
#&gt; (Intercept)   39.625      4.225    9.38  2.8e-10 ***
#&gt; cyl           -3.091      0.558   -5.54  5.7e-06 ***
#&gt; vs            -0.939      1.978   -0.47     0.64    
#&gt; ---
#&gt; Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
#&gt; 
#&gt; Residual standard error: 3.25 on 29 degrees of freedom
#&gt; Multiple R-squared:  0.728,  Adjusted R-squared:  0.71 
#&gt; F-statistic: 38.9 on 2 and 29 DF,  p-value: 6.23e-09</code></pre>
<p>实际上，<code>summary()</code>的输出结果也是一个对象，包含的数据都可以被访问。在这个例子里，这个对象是一个列表，是<code>summary.lm</code>类，它有可供<code>print()</code>选择的自己的方法：</p>
<pre class="r"><code>lm1summary = summary(lm1)
typeof(lm1summary)
#&gt; [1] &quot;list&quot;

class(lm1summary)
#&gt; [1] &quot;summary.lm&quot;</code></pre>
<p>查看列表成分：</p>
<pre class="r"><code>names(lm1summary)
#&gt;  [1] &quot;call&quot;          &quot;terms&quot;         &quot;residuals&quot;     &quot;coefficients&quot; 
#&gt;  [5] &quot;aliased&quot;       &quot;sigma&quot;         &quot;df&quot;            &quot;r.squared&quot;    
#&gt;  [9] &quot;adj.r.squared&quot; &quot;fstatistic&quot;    &quot;cov.unscaled&quot;</code></pre>
<p>还有一些其他有用的且与模型相关的泛型函数，例如<code>plot()</code>,<code>predict()</code>。不同的内置模型和第三方扩展包提供的模型都能实现这些泛型函数。</p>
<p>举例，我们可以对线性模型调用<code>plot()</code>函数：</p>
<pre class="r"><code>oldpar = par(mfrow = c(2, 2))
plot(lm1)</code></pre>
<p><img src="/post/2018-08-15-high-level-and-OOP_files/figure-html/unnamed-chunk-15-1.png" width="672" /></p>
<pre class="r"><code>par(oldpar)</code></pre>
<p>为避免依次生成这4个图，我们用<code>par()</code>将绘图区域划分为2x2的子区域。</p>
<p>利用<code>predict()</code>我们可以使用模型对新数据进行预测，泛型函数<code>predict()</code>自动选择正确的方法用新数据进行预测：</p>
<pre class="r"><code>predict(lm1, data.frame(cyl = c(6, 8), vs = c(1, 1)))
#&gt;    1    2 
#&gt; 20.1 14.0</code></pre>
<p><strong>这个函数既可以用在样本内，又可以用在样本外</strong>。如果我们为模型提供新数据，它就进行样本外预测。</p>
<p>下面我们创建一幅真实值和拟合值的散点图，看一看线性模型的预测效果：</p>
<pre class="r"><code>plot(mtcars$mpg, fitted(lm1))</code></pre>
<p><img src="/post/2018-08-15-high-level-and-OOP_files/figure-html/unnamed-chunk-17-1.png" width="672" /></p>
<p>这里的<code>fitted()</code>也是泛型函数，等价于<code>lm1$fitted.values</code>，拟合值等于用原始数据得到的预测值，即用原始数据构建的模型预测原始数据，<code>predict(lm1, mtcars)</code>。</p>
<p>真实值与拟合值的差称为残差，可以通过另一个泛型函数<code>residuals()</code>获得。</p>
<pre class="r"><code>plot(density(residuals(lm1)),
     main = &quot;Density of lm1 residuals&quot;)</code></pre>
<p><img src="/post/2018-08-15-high-level-and-OOP_files/figure-html/unnamed-chunk-18-1.png" width="672" /></p>
<p>这些泛型函数不仅适用于<code>lm</code>、<code>glm</code>和其他内置模型，也适用于其他扩展包提供的模型。</p>
<p>例如我们使用<code>rpart</code>包，使用前面的数据和公式拟合一个回归树模型。</p>
<pre class="r"><code>if(!require(&quot;rpart&quot;)) install.packages(&quot;rpart&quot;)
#&gt; 载入需要的程辑包：rpart
library(rpart)</code></pre>
<pre class="r"><code>tree_model = rpart(mpg ~ cyl + vs, data = mtcars)</code></pre>
<p>我们之所以能够使用相同的方法，<strong>是因为这个包的作者希望函数调用的方式与调用R内置函数保持一致</strong>。</p>
<pre class="r"><code>typeof(tree_model)
#&gt; [1] &quot;list&quot;
class(tree_model)
#&gt; [1] &quot;rpart&quot;</code></pre>
<p>打印模型：</p>
<pre class="r"><code>print(tree_model)
#&gt; n= 32 
#&gt; 
#&gt; node), split, n, deviance, yval
#&gt;       * denotes terminal node
#&gt; 
#&gt; 1) root 32 1130.0 20.1  
#&gt;   2) cyl&gt;=5 21  198.0 16.6  
#&gt;     4) cyl&gt;=7 14   85.2 15.1 *
#&gt;     5) cyl&lt; 7 7   12.7 19.7 *
#&gt;   3) cyl&lt; 5 11  203.0 26.7 *</code></pre>
<p>更详细信息：</p>
<pre class="r"><code>summary(tree_model)
#&gt; Call:
#&gt; rpart(formula = mpg ~ cyl + vs, data = mtcars)
#&gt;   n= 32 
#&gt; 
#&gt;       CP nsplit rel error xerror   xstd
#&gt; 1 0.6431      0     1.000  1.098 0.2556
#&gt; 2 0.0893      1     0.357  0.410 0.0789
#&gt; 3 0.0100      2     0.268  0.402 0.0799
#&gt; 
#&gt; Variable importance
#&gt; cyl  vs 
#&gt;  65  35 
#&gt; 
#&gt; Node number 1: 32 observations,    complexity param=0.643
#&gt;   mean=20.1, MSE=35.2 
#&gt;   left son=2 (21 obs) right son=3 (11 obs)
#&gt;   Primary splits:
#&gt;       cyl &lt; 5   to the right, improve=0.643, (0 missing)
#&gt;       vs  &lt; 0.5 to the left,  improve=0.441, (0 missing)
#&gt;   Surrogate splits:
#&gt;       vs &lt; 0.5 to the left,  agree=0.844, adj=0.545, (0 split)
#&gt; 
#&gt; Node number 2: 21 observations,    complexity param=0.0893
#&gt;   mean=16.6, MSE=9.45 
#&gt;   left son=4 (14 obs) right son=5 (7 obs)
#&gt;   Primary splits:
#&gt;       cyl &lt; 7   to the right, improve=0.507, (0 missing)
#&gt;   Surrogate splits:
#&gt;       vs &lt; 0.5 to the left,  agree=0.857, adj=0.571, (0 split)
#&gt; 
#&gt; Node number 3: 11 observations
#&gt;   mean=26.7, MSE=18.5 
#&gt; 
#&gt; Node number 4: 14 observations
#&gt;   mean=15.1, MSE=6.09 
#&gt; 
#&gt; Node number 5: 7 observations
#&gt;   mean=19.7, MSE=1.81</code></pre>
<p>下面对结果进行可视化，得到树图：</p>
<pre class="r"><code>oldpar = par(xpd = NA)
plot(tree_model)
text(tree_model, use.n = TRUE)</code></pre>
<p><img src="/post/2018-08-15-high-level-and-OOP_files/figure-html/unnamed-chunk-24-1.png" width="672" /></p>
<pre class="r"><code>par(oldpar)</code></pre>
</div>
<div class="section level3">
<h3>为现有类定义泛型函数</h3>
<p><strong>在定义泛型函数时，我们创建一个函数去调用<code>UseMethod()</code>出发方法分派。然后对泛型函数想要作用的类创建带有<code>method.class</code>形式的方法函数，同时还要创建带有<code>method.default</code>形式的默认方法来应对所有其他情况</strong>。</p>
<p>下面我们创建一个新的泛型函数<code>generic_head()</code>，它有两个参数：<strong>输入对象<code>x</code>和需要提取的记录条数<code>n</code></strong>。泛型函数仅仅调用<code>UseMethod(&quot;generic_head&quot;)</code>来让R根据输入对象<code>x</code>的类执行方法分派。</p>
<pre class="r"><code>generic_head = function(x, n)
    UseMethod(&quot;generic_head&quot;)</code></pre>
<p>对原子向量提取前<code>n</code>个元素，因此分别定义<code>generic_head.numeric</code>、<code>generic_head.character</code>等，另外最好定义一个默认方法捕获不能匹配的其他所有情况：</p>
<pre class="r"><code>generic_head.default = function(x, n){
    x[1:n]
}</code></pre>
<p>现在<code>generic_head</code>只有一种方法，等于没有使用泛型函数：</p>
<pre class="r"><code>generic_head(num_vec, 3)
#&gt; [1] 1 2 3</code></pre>
</div>
</div>
