---
title: "R的内部机制"
author: 王诗翔
date: 2018-08-01
slug: "give a english slug for your post"
categories: 
    - R
tags:
    - r

---
```{r setup, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE, dev = "png")
#Sys.setlocale('LC_ALL','C') # Embed this directly in the Rmarkdown script that contains the Chinese character comment
options(digits=3)
options(max.print=200)
```


内容：

> * 惰性求值 （Lazy evaluation）
> * 复制-修改机制 （Copy-on-modify mechanism）
> * 词法作用域 （Lexical scoping）
> * 环境 （Environment）

理解这些概念能够明白大部分的R代码，同时提升工作效率。

## 惰性求值

创建如下函数：

```{r}
test0 = function(x, y) {
    if (x > 0) x else y
}
```


函数在`x`不大于0时才需要`y`的存在，如果我们只为该函数设定`x`参数，函数会因为`y`不存在而报错么?

```{r}
test0(1)
```


即使没有对`y`赋值，函数竟然仍能够运行！**看来调用函数时不必对所有的参数进行赋值，只对必需参数赋值即可**。当然，如果这里`x`是一个负数，必须有`y`值的存在：

```{r, error=TRUE}
test0(-1)
```

我们已知知道函数并不需要指定所有参数，如果指定了额外的参数，R是在调用函数前进行计算，还是根本就不会计算呢？

我们使用`stop()`函数来探究一番：

```{r, error=TRUE}
test0(1, stop("Stop Now!"))
test0(-1, stop("Stop Now!"))
```

很明显，`stop()`函数在第一个语句中没起到作用，在第二个语句中起作用了，说明参数只有在**实际用到**时才会被执行。这个机制称为**惰性求值**。

惰性求值是按需计算，可以节省时间并避免不必要的计算。如果你对它不了解，你可能会认为执行以下操作会比较耗时：

```
test0(1, rnorm(10000000))
```

我们来看下：

```{r}
system.time(test0(1, rnorm(10000000)))
```

而本身`rnorm`执行的时间为：

```{r}
system.time(rnorm(10000000))
```

用我的计算机需要超过1秒的时间生成1千万个随机数，而运行`test0()`函数的消耗几乎为0。由此可见，在需要时再计算可以减少不必要的浪费。也许你会说，1秒算什么，但如果你的程序中循环迭代使用几千上万次这样的运算呢？那可是小时乃至天了。

但惰性求值也是把双刃剑，**在调用函数时，其参数只被解析而不被计算（使用时才计算），所有我们只能确定参数表达式在语法上是正确的，但很难确定它的有效性。**

如果我们把函数

```
test2 = function(x, n=floor(length(x) / 2)){
    x[1:n]
}
```

写成了：

```{r}
test3 = function(x, n=floor(length(m) / 2)){
    x[1:n]
}
```

因为创建函数时并不计算，所以创建`test3`时并不会报错，只有实际调用时才会报错：

```{r, error=TRUE}
test3(1:10)
```

有趣的是，利用惰性求值我们可以创建一些有意思的函数用法，比如下面函数控制输入参数只接受`y`或`n`，否则报错：

```{r}
check_input = function(x){
    switch (x,
        y = message("yes"),
        n = message("no"),
        stop("Invalid input...")
    )
}
```

使用看看：

```{r, error=TRUE}
check_input("y")
check_input("n")
check_input("what")
```

## 复制-修改机制

这里介绍R的一个重要特性，以便于更安全地使用数据。

先创建一个数值向量`x1`，并赋值给`x2`：

```{r}
x1 = c(1, 2, 3)
x2 = x1
```

现在`x1`与`x2`值完全相同，如果我们修改其中一个，另一个也会跟着改变吗？

```{r}
x1[1] = 0
x1
x2
```

结果显示`x1`的改变不会影响`x2`，我们可能以为**赋值操作会自动复制值，然后使新变量指向数据的副本，而不是原始数据**，那么实际如何我们用`tracemem()`函数来追踪一下。

先重置`x1`与`x2`，再追踪：

```{r}
x1 = c(1, 2, 3)
x2 = x1
tracemem(x1)
tracemem(x2)
```

**可以发现两个向量值相同，并共享内存地址**，说明它们指向相同的数据，而赋值操作并没有自动复制数据！那么数据是什么时候被复制了呢？

```{r}
x1[1] = 0
```

内存追踪到`x1`的地址发生了改变。

**如果多个变量指向同一对象，那么修改一个变量会生成该对象的一个副本，这就是复制——修改机制**。

另外，修改函数的参数和对象属性也会生成一个新的副本以确保外部的对象不受影响。

### 修改函数外部的对象

如果我们在运行函数时想要修改外部对象的值怎么办？运算符`<<-`可以执行这一操作：

```{r}
x = 0
modify_x = function(value) {
    x <<- value
}
```

调用函数会更改`x`：

```{r}
modify_x(3)
```

```{r}
x
```


运算符`<<-`的一个用法是“拉平”一个嵌套列表。假设我们有如下列表：

```{r}
nested_list = list(
    a = c(1, 2, 3),
    b = list(
        x = c("a", "b", "c"),
        y = list(
            z = c(TRUE, FALSE),
            w = c(2, 3, 4)
        )
    )
)

str(nested_list)
```

我们现在想要拉平该列表——即将所有的嵌套部分放在最外层。以下代码使用`rapply()`于`<<-`实现这一过程。`rapply()`是`lapply()`的递归版本，每一次迭代都将函数作用到列表特定的原子向量上。

先创建一个用于存放嵌套向量的空列表和一个计数器：

```{r}
flat_list = list()
i = 1
```

然后利用`rapply()`将一个函数递归应用到`nested_list()`列表上，每一次迭代，函数通过`x`获得一个该列表的原子向量，然后将`flat_list`的第`i`个元素设为`x`，并将`i`加1。

```{r}
res = rapply(nested_list, function(x) {
    flat_list[[i]] <<- x
    i <<- i + 1
})

res
```

我们再将`res`中的元素名赋给`flat_list`，以标明每个元素的原始层级。

```{r}
names(flat_list) = names(res)
str(flat_list)
```

至此，实现完成。

## 词法作用域

一般也常称为变量作用域，这常体现在函数的使用中。函数有内部与外部之分，在函数的内部，我们能够使用外部变量和函数，但外部不能使用内部变量和函数（除非使用`<<-`创建全局变量）。

例如：

```{r}
start1 = 1
end1 = 10
fun1 = function(x){
    c(start1, x, end1)
}

fun1(c(4,5,6))
```

可以看到函数`fun1`只有一个参数，但它却可以使用函数外部定义的变量。

在本文最前面讲述了“惰性求值”，此处函数虽然只设定了`x`参数，但在函数的使用时它发现`start`与`end`参数不在函数内部，所以它会尝试往上一级寻找（直到最高一级，即这里函数的外部），如果寻找不到，则报错。

使用函数内部参数：

```{r}
fun2 = function(x, start1=2, end1=3){
    c(start1, x, end1)
}

fun2(c(4,5,6))
```

如果参数不存在：

```{r, error=TRUE}
rm(start1, end1)
fun1 = function(x){
    c(start1, x, end1)
}

fun1(c(4,5,6))
```

## 环境的工作方式

我们前面学习的惰性求值、复制-修改机制和词法作用域与一种对象高度相关，那就是**环境**。

### 环境对象

**环境是一组名称组成的对象，每个环境（除了空环境）都有一个父环境**。每个名称（称符号或变量）都指向一个对象，当我们查找一个符号时，**如果它在当前环境中，R就会在当前环境中搜索并返回该符号指向的对象。如果这个符号在当前环境中没有找到，R就会到它的父环境中搜索（直到找遍所有环境）**。

### 创建并连接环境

