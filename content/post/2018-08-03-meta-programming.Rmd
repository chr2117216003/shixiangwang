---
title: "元编程"
author: 王诗翔
date: 2018-08-03
slug: "meta-programming"
categories: 
    - R
tags:
    - metaProgramming
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE, dev = "png")
#Sys.setlocale('LC_ALL','C') # Embed this directly in the Rmarkdown script that contains the Chinese character comment
options(digits=3)
options(max.print=200)
```


内容：

> * 函数式编程：闭包（closures）与高阶函数（higher-order functions）
> * 基于语言计算以及语言对象
> * 非标准计算（non-standard evaluation）

## 函数式编程

我们将学习两种函数：**一种是在函数内部定义的函数，另一种是与其他函数组合使用的函数**。

### 创建和使用闭包

函数内部定义的函数称为闭包（closure）。**闭包的特点是在函数体内，我们可以使用局部参数，也可以使用父环境中的变量**。

现用实例说明，假设有函数：

```{r}
add = function(x, y){
    x + y
}
```

该函数有两个参数，每次调用时都需要提供它们。**如果使用闭包，我们可以生成事先带指定参数的特殊版本**。

#### 创建简单闭包

现在我们创建一个叫`addn()`的参数：

```{r}
addn = function(y) {
    function(x){
        x + y
    }
}
```

该函数包含参数`y`，内部创建一个带参数`x`的子函数，将`y`加到参数`x`上。

这里读者需要仔细思考。函数`addn`跟我们一般接触的函数都不相同，它的结果不会返回一个数值，而是一个闭包，**即定义在函数内部的函数**。该闭包计算`x+y`的值，`x`是局部参数，`y`是闭包封闭环境中的参数。整体而言，`addn`不是一个加法器，而是一个生成加法器的工厂！

该函数工厂（闭包）可以让我们创建专用的函数，比如创建两个函数分别用于对参数加1和加2：

```{r}
add1 = addn(1)
add2 = addn(2)
```

这两个函数的实际效果与`add(y, 1)`与`add(y, 2)`完全等同。

```{r}
add1(10)
add2(10)
```

```{r}
add
add1
```

比较上面两条语句可以发现，`add1`与`add`函数不同，输出结果附带了`add1`的环境。**这是因为一个函数不在当前环境（例子中为全局环境）下，那么输出该函数就会一并显示其所属的环境**。在`add1`的环境中，`y是在addn(1)`确定的，下面可以证实：

```{r}
environment(add1)$y
```

这里我们调用了`environment()`函数访问其封闭环境用来捕捉`y`，这个过程就是闭包的工作方式。

#### 创建专用函数

闭包对于创建专用函数非常有用。例如，我们使用一个专用的简化绘图函数，只使用部分参数，这样的代码更容易编写和阅读：

```{r}
color_line = function(col){
    function(...){
        plot(..., type = "l", lty = 1, col = col)
    }
}
```

上面函数可以用来创建一个专门画红色线条的函数。

使用效果如下：

```{r}
red_line = color_line("red")
red_line(rnorm(30), main = "Red line plot")
```

#### 使用极大似然估计拟合正态分布

闭包在使用一个含有给定数据的算法时很有用。比如，在统计学中很多参数估计问题本质上就是最优化问题——在给定约束条件和数据，找出使目标函数最大化或最小化的一组参数。

**极大似然估计MLE是一个很好的例子，它的想法是：给定一个模型，参数的估计值应使观测数据最可能发生**。

**对参数进行极大似然估计时，我们需要一个函数来衡量给定模型下观测到一组给定数据的可能性，然后运用最优化技术找出使上述概率最大化的参数值**。

例如我们知道一组由正态分布产生的观测数据，但是不知道参数：均值和标准差。这里根据给出的数据，用极大似然估计估计这两者的值。

首先，正态分布的密度函数为：

$$
f(x) = \frac{1}{\sqrt{2\pi}\sigma} exp(-\frac{1}{2}\frac{(x-\mu_0)^2}{\sigma_0^2})
$$


因此，给定观测数据`x`，其似然函数为：

$$
L(\mu,\sigma; x) = (2\pi\sigma^2)^{-\frac{n}{2}} exp(-\frac{1}{2\sigma_0^2}\sum{(x_i-\mu)^2})
$$

（不懂怎么来的，百度学习下）

下面两边同时取对数并加负号：

$$
-l(\mu,\sigma;x) = \frac{n}{2}ln(2\pi)+\frac{n}{2}ln(\sigma^2) + \frac{1}{2\sigma^2}\sum{(x_i - \mu)^2}
$$

**负对数似然函数与原函数单调性相同，所以其最优化的解也与原函数相同，但求解过程却简单得多。**因此MLE通常使用对数似然函数来求解。

下面定义函数，当给定观测数据`x`后，该函数会返回包含正态分布的两个参数的闭包：

```{r}
nloglik = function(x){
    n = length(x)
    function(mean, sd){
        log(2 * pi) * n / 2 + log(sd ^ 2) * n / 2 + sum((x - mean) ^2) / (2 * sd ^ 2)
    }
}
```

**这样对于任意给定的观测数据集，我们都可以调用`nloglik()`函数得到参数为均值和标准差的负对数似然函数**。它说明了**在假定真实模型的两个参数分别为`mean`和`sd`时，不能观测到给定数据的可能性有多大**。

下面用10000个均值为1，标准差为2的正态分布随机数做测试，使用`stat4`包的`mle()`函数求解（需要设定数值搜索的起点和解的上下界）。

```{r}
data = rnorm(10000, 1, 2)

fit = stats4::mle(nloglik(data),
                  start = list(mean=0, sd=1), method = "L-BFGS-B",
                  lower = c(-5, 0.01), upper = c(5, 10))
```

结果返回一个`S4`对象：

```{r}
fit@coef
```

可以看到，估计值非常接近真实值。下面使用图形展示这一点。

```{r}
hist(data, freq = FALSE, ylim = c(0, 0.25))
curve(dnorm(x, 1, 2), add = TRUE, col = rgb(1, 0, 0, 0.5), lwd = 6)
curve(dnorm(x, fit@coef[["mean"]], fit@coef[["sd"]]),
      add = TRUE, col = "blue", lwd = 2)
```

红色的真实值和蓝色的模拟值曲线非常接近。

### 使用高阶函数

何谓高阶函数？**将另一个函数作为参数的函数**。

R的函数也是对象，可以用变量进行引用，也可以将函数当作参数传递。

像`+`与`-`这样的操作符其实本质也是函数，知道这一点，我们便可以简化下面函数：

```{r}
f1 = function(x, y){
    if (x > y) {
        x + y
    }else {
        x -y
    }
}
```

考虑到通过条件判断执行不同的操作，其实就是一个选择使用函数的过程：

```{r}
f2 = function(x, y){
    op = if (x > y) `+` else `-`
    op(x, y)
}
```


`f2`与`f1`完全等同。

下面举一个函数作为参数的例子：

```{r}
add = function(x, y, z ){
    x + y + z
}

product = function(x, y, z){
    x * y * z
}

combine = function(f, x, y, z){
    f(x, y, z)
}
```

我们先创建了一个3个数的加法和乘法函数，然后定义`combine()`函数，以参数`f`的方式组合前面两个函数，这样我们可以根据需要选择适合的函数。

```{r}
combine(add, 3, 4, 5)
combine(product, 3, 4, 5)
```

**高阶函数使代码在更高的抽象化层次下读写起来更容易**。

在R中，`apply`家族就是典型的高阶函数，支持向量化操作。除了常见的`apply`、`lapply`等带`apply`名字的函数，还包含`Filter()`、`Map()`、`Reduce()`、`Find()`、`Position()`、`Negate()`函数（详情`?Filter`）。

## 基于语言的计算

函数只是另一种可被传递的对象，当调用函数时，一个**新的包含尚未求值的实参（`promise`）的执行环境被创建，以支持函数的执行，这正是惰性求值的基础。

元编程允许我们调整语言本身，使得特定的语言结构在特定情况下更方便使用。这一节我们一起学习它的优缺点。

我们先看看元编程如何使得工作变得更简单。

假设我们现在想把`iris`数据集中每个数值列超过`80%`的项筛选出来。

标准方法为：

```{r}
iris[iris$Sepal.Length > quantile(iris$Sepal.Length, 0.8) & 
         iris$Sepal.Width > quantile(iris$Sepal.Width, 0.8) & 
         iris$Petal.Length > quantile(iris$Petal.Length, 0.8) &
         iris$Petal.Width > quantile(iris$Petal.Width, 0.8), ]
```

上述代码在逻辑上非常清楚，但过程非常繁琐。我们使用了8次`iris$`。

内置函数`subset()`可以简化：

```{r}
subset(iris,
       Sepal.Length > quantile(Sepal.Length, 0.8) & 
         Sepal.Width > quantile(Sepal.Width, 0.8) & 
         Petal.Length > quantile(Petal.Length, 0.8) &
         Petal.Width > quantile(Petal.Width, 0.8))
```

可以看到返回结果完全相同，后者看起来更简洁。为什么上述代码省略了`iris$`依旧可以运行，但前面代码就不能省略呢（你可以省略试试）。

`subset()`函数使用元编程技术调整了其参数的计算环境，使表达式`Sepal.Length > quantile(Sepal.Length, 0.8)`在包含`iris`所有列的环境中被计算（有接触过`attach`吗？）。

此外，`subset()`还调整了列的选取：

```{r}
subset(iris,
       Sepal.Length > quantile(Sepal.Length, 0.8) & 
         Sepal.Width > quantile(Sepal.Width, 0.8) & 
         Petal.Length > quantile(Petal.Length, 0.8) &
         Petal.Width > quantile(Petal.Width, 0.8), select = c(Sepal.Length, Petal.Length, Species))
```

接下来我们学习代码背后的机制及工作原理。

### 捕获和修改表达式

当我们在交互式控制台键入表达式并按下`Enter`后，R便会执行并输出结果。

例如：

```{r}
rnorm(5)
```

`subset()`神奇之处在于它调整了参数被计算的环境，分两步完成，**首先捕获表达式，然后调整表达式的计算**。

#### 将表达式捕获为语言对象

**捕获表达式意味着防止表达式被执行，而将表达式本身存储为变量的形式**。具有这个功能的函数为`quote()`：

```{r}
call = quote(rnorm(5))
call
```

上述代码返回代码本身而不是表达式执行的结果，我们可以使用`typeof()`和`class()`观察返回的对象：

```{r}
typeof(call)
class(call)
```


`call`本质上是一个语言对象，并且是一个函数调用。我们还可以在`quote()`中写函数名：

```{r}
name1 = quote(rnorm)
name1

typeof(name1)
class(name1)
```

结果是一个符号（或名称）而不是函数调用。

**事实上，`quote()`捕捉到函数调用时会返回调用，而捕获到变量名时则返回一个符号**。唯一的要求是代码语法正确，`quote()`就会返回表示被捕获表达式本身的语言对象。即便函数不存在或变量未定义。

```{r}
quote(pvar)

quote(xfun(a = 1:n))
```


理解变量和符号对象的区别，以及函数和调用对象的区别非常重要。变量是对象的名称，而符号对象是名称本身。函数是可以被调用的对象，而调用对象是不会被计算的，它表示这个函数调用的语言对象。