---
title: "R-数据操作"
author: 王诗翔
date: 2018-08-25
slug: "r-hight-level-data-operation"
categories: 
    - R
tags:
    - dplyr
    - sqldf
    - data.table
    - rlist
---



<blockquote>
<p>本文内容：</p>
<ul>
<li>基础函数操作数据框</li>
<li>sqldf包使用SQL查询数据框</li>
<li>data.table包操作数据</li>
<li>dplyr管道操作处理数据</li>
<li>rlist包处理嵌套数据结构</li>
</ul>
</blockquote>
<div class="section level2">
<h2>使用内置函数操作数据框</h2>
<p><strong>数据框的本质是一个由向量构成的列表</strong>，由于列长度相同，所以可以当做矩阵进行访问和操作。比如选择满足特定条件的行，使用<code>[]</code>符号，第一个参数提供一个逻辑向量，第二个参数留空。</p>
<p>本文大部分的代码都是基于一组产品的虚拟数据。我们先将数据载入，然后学习怎么用不同的方法操作数据。</p>
<pre class="r"><code>if(!require(readr)) install.packages(&quot;readr&quot;)
#&gt; 载入需要的程辑包：readr

product_info = read_csv(&quot;../../R/dataset/product-info.csv&quot;)
#&gt; Parsed with column specification:
#&gt; cols(
#&gt;   id = col_character(),
#&gt;   name = col_character(),
#&gt;   type = col_character(),
#&gt;   class = col_character(),
#&gt;   released = col_character()
#&gt; )
product_info
#&gt; # A tibble: 6 x 5
#&gt;   id    name      type  class   released
#&gt;   &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   
#&gt; 1 T01   SupCar    toy   vehicle yes     
#&gt; 2 T02   SupPlane  toy   vehicle no      
#&gt; 3 M01   JeepX     model vehicle yes     
#&gt; 4 M02   AircraftX model vehicle yes     
#&gt; 5 M03   Runner    model people  yes     
#&gt; 6 M04   Dancer    model people  no</code></pre>
<p>当数据以数据框的形式载入内存后，我们可以使用下面的代码查看每一列的类型：</p>
<pre class="r"><code>sapply(product_info, class)
#&gt;          id        name        type       class    released 
#&gt; &quot;character&quot; &quot;character&quot; &quot;character&quot; &quot;character&quot; &quot;character&quot;</code></pre>
<p>注意<code>read_csv</code>函数载入的数据框与内置函数<code>read.csv</code>函数是不同的，主要体现在不会将字符串转换为因子变量，当然前者的速度要快得多。</p>
<p>接下来我们正式学习用R内置的函数操作数据框进行分析和统计的一些方法。</p>
<div class="section level3">
<h3>内置函数操作数据框</h3>
<p>选取<code>type</code>为<code>toy</code>的行：</p>
<pre class="r"><code>product_info[product_info$type == &quot;toy&quot;, ]
#&gt; # A tibble: 2 x 5
#&gt;   id    name     type  class   released
#&gt;   &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   
#&gt; 1 T01   SupCar   toy   vehicle yes     
#&gt; 2 T02   SupPlane toy   vehicle no</code></pre>
<p>或选取<code>released</code>为<code>no</code>的行：</p>
<pre class="r"><code>product_info[product_info$released == &quot;no&quot;, ]
#&gt; # A tibble: 2 x 5
#&gt;   id    name     type  class   released
#&gt;   &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   
#&gt; 1 T02   SupPlane toy   vehicle no      
#&gt; 2 M04   Dancer   model people  no</code></pre>
<p><strong>对列进行筛选</strong>需要将第1个参数留空，给第2个参数提供字符向量。</p>
<pre class="r"><code>product_info[, c(&quot;id&quot;, &quot;name&quot;, &quot;type&quot;)]
#&gt; # A tibble: 6 x 3
#&gt;   id    name      type 
#&gt;   &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;
#&gt; 1 T01   SupCar    toy  
#&gt; 2 T02   SupPlane  toy  
#&gt; 3 M01   JeepX     model
#&gt; 4 M02   AircraftX model
#&gt; 5 M03   Runner    model
#&gt; 6 M04   Dancer    model</code></pre>
<p>行列筛选也是可以的，我们只要组合前面的两种情况即可。</p>
<pre class="r"><code>product_info[product_info$type == &quot;toy&quot;, c(&quot;name&quot;, &quot;class&quot;, &quot;released&quot;)]
#&gt; # A tibble: 2 x 3
#&gt;   name     class   released
#&gt;   &lt;chr&gt;    &lt;chr&gt;   &lt;chr&gt;   
#&gt; 1 SupCar   vehicle yes     
#&gt; 2 SupPlane vehicle no</code></pre>
<p>内置函数<code>subset()</code>可以简化取子集操作的过程：</p>
<pre class="r"><code>subset(product_info,
       subset = type == &quot;model&quot; &amp; released == &quot;yes&quot;,
       select = name:class)
#&gt; # A tibble: 3 x 3
#&gt;   name      type  class  
#&gt;   &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt;  
#&gt; 1 JeepX     model vehicle
#&gt; 2 AircraftX model vehicle
#&gt; 3 Runner    model people</code></pre>
<p>使用<code>with()</code>函数在数据框的语义中计算表达式，即可以直接使用数据框的列名，而不必重复指定数据框：</p>
<pre class="r"><code>with(product_info, name[released == &quot;no&quot;])
#&gt; [1] &quot;SupPlane&quot; &quot;Dancer&quot;</code></pre>
<p>除了构建子集，表达式还可以用来统计每列各个可能值出现的频数。</p>
<pre class="r"><code>with(product_info, table(type[released == &quot;yes&quot;]))
#&gt; 
#&gt; model   toy 
#&gt;     3     1</code></pre>
<p>除了产品信息表，还有一张产品属性的统计表：</p>
<pre class="r"><code>product_stats = read_csv(&quot;../../R/dataset/product-stats.csv&quot;)
#&gt; Parsed with column specification:
#&gt; cols(
#&gt;   id = col_character(),
#&gt;   material = col_character(),
#&gt;   size = col_integer(),
#&gt;   weight = col_double()
#&gt; )
product_stats
#&gt; # A tibble: 6 x 4
#&gt;   id    material  size weight
#&gt;   &lt;chr&gt; &lt;chr&gt;    &lt;int&gt;  &lt;dbl&gt;
#&gt; 1 T01   Metal      120   10  
#&gt; 2 T02   Metal      350   45  
#&gt; 3 M01   Plastics    50   NA  
#&gt; 4 M02   Plastics    85    3  
#&gt; 5 M03   Wood        15   NA  
#&gt; 6 M04   Wood        16    0.6</code></pre>
<p><strong>如果现在要获取尺寸最大的前3个产品的名字该怎么办？</strong></p>
<p>一种方法是将<code>product_stats</code>按尺寸降序排列，选择前3个记录的id，然后用id值筛选<code>product_info</code>的行：</p>
<pre class="r"><code>top3_id = unlist(product_stats[order(product_stats$size, decreasing = TRUE), &quot;id&quot;])[1:3]

product_info[product_info$id %in% top3_id, ]
#&gt; # A tibble: 3 x 5
#&gt;   id    name      type  class   released
#&gt;   &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   
#&gt; 1 T01   SupCar    toy   vehicle yes     
#&gt; 2 T02   SupPlane  toy   vehicle no      
#&gt; 3 M02   AircraftX model vehicle yes</code></pre>
<p>我们用比较冗长的方式完成了任务。但仔细在想想，两个数据框是通过<code>id</code>连接到一起的，我们可以把它们合并到一起，然后执行提取操作：</p>
<pre class="r"><code>product_table = merge(product_info, product_stats, by = &quot;id&quot;)
product_table
#&gt;    id      name  type   class released material size weight
#&gt; 1 M01     JeepX model vehicle      yes Plastics   50     NA
#&gt; 2 M02 AircraftX model vehicle      yes Plastics   85    3.0
#&gt; 3 M03    Runner model  people      yes     Wood   15     NA
#&gt; 4 M04    Dancer model  people       no     Wood   16    0.6
#&gt; 5 T01    SupCar   toy vehicle      yes    Metal  120   10.0
#&gt; 6 T02  SupPlane   toy vehicle       no    Metal  350   45.0</code></pre>
<p>现在通过合并的数据框，我们可以根据任意一列排序数据框，而不需要处理其他的表格数据：</p>
<pre class="r"><code>product_table[order(product_table$size), ]
#&gt;    id      name  type   class released material size weight
#&gt; 3 M03    Runner model  people      yes     Wood   15     NA
#&gt; 4 M04    Dancer model  people       no     Wood   16    0.6
#&gt; 1 M01     JeepX model vehicle      yes Plastics   50     NA
#&gt; 2 M02 AircraftX model vehicle      yes Plastics   85    3.0
#&gt; 5 T01    SupCar   toy vehicle      yes    Metal  120   10.0
#&gt; 6 T02  SupPlane   toy vehicle       no    Metal  350   45.0</code></pre>
<p>前面的问题我们也可以利用合并的数据框加以解决：</p>
<pre class="r"><code>product_table[order(product_table$size, decreasing = TRUE), &quot;name&quot;][1:3]
#&gt; [1] &quot;SupPlane&quot;  &quot;SupCar&quot;    &quot;AircraftX&quot;</code></pre>
<p>有时候我们需要生成新数据框来对原始数据基础上进行调整和处理，从而避免破坏原始数据。<code>transform()</code>函数可以帮助我们完成这类任务，例如：</p>
<pre class="r"><code>transform(product_table,
          released = ifelse(released == &quot;yes&quot;, TRUE, FALSE),
          density = weight / size)
#&gt;    id      name  type   class released material size weight density
#&gt; 1 M01     JeepX model vehicle     TRUE Plastics   50     NA      NA
#&gt; 2 M02 AircraftX model vehicle     TRUE Plastics   85    3.0  0.0353
#&gt; 3 M03    Runner model  people     TRUE     Wood   15     NA      NA
#&gt; 4 M04    Dancer model  people    FALSE     Wood   16    0.6  0.0375
#&gt; 5 T01    SupCar   toy vehicle     TRUE    Metal  120   10.0  0.0833
#&gt; 6 T02  SupPlane   toy vehicle    FALSE    Metal  350   45.0  0.1286</code></pre>
<p>前面数据中我们看到有一些缺失值（用<code>NA</code>表示），很多时候我们不希望数据出现任何缺失值，因此需要某种办法处理它们。为了演示处理的方法，我们再载入一张包含缺失值的表，包含每件产品的质量、耐久性、防水性的测试结果。</p>
<pre class="r"><code>product_tests = read_csv(&quot;../../R/dataset/product-tests.csv&quot;)
#&gt; Parsed with column specification:
#&gt; cols(
#&gt;   id = col_character(),
#&gt;   quality = col_integer(),
#&gt;   durability = col_integer(),
#&gt;   waterproof = col_character()
#&gt; )
product_tests
#&gt; # A tibble: 6 x 4
#&gt;   id    quality durability waterproof
#&gt;   &lt;chr&gt;   &lt;int&gt;      &lt;int&gt; &lt;chr&gt;     
#&gt; 1 T01        NA         10 no        
#&gt; 2 T02        10          9 no        
#&gt; 3 M01         6          4 yes       
#&gt; 4 M02         6          5 yes       
#&gt; 5 M03         5         NA yes       
#&gt; 6 M04         6          6 yes</code></pre>
<p><code>na.omit()</code>可以删除所有包含缺失值的行：</p>
<pre class="r"><code>na.omit(product_tests)
#&gt; # A tibble: 4 x 4
#&gt;   id    quality durability waterproof
#&gt;   &lt;chr&gt;   &lt;int&gt;      &lt;int&gt; &lt;chr&gt;     
#&gt; 1 T02        10          9 no        
#&gt; 2 M01         6          4 yes       
#&gt; 3 M02         6          5 yes       
#&gt; 4 M04         6          6 yes</code></pre>
<p>另外，函数<code>complete.cases()</code>可以返回逻辑向量，表明某行是否完整。</p>
<pre class="r"><code>complete.cases(product_tests)
#&gt; [1] FALSE  TRUE  TRUE  TRUE FALSE  TRUE</code></pre>
<p>利用该函数可以筛选数据框，比如获得不含缺失值的<code>id</code>值：</p>
<pre class="r"><code>product_tests[complete.cases(product_tests), &quot;id&quot;]
#&gt; # A tibble: 4 x 1
#&gt;   id   
#&gt;   &lt;chr&gt;
#&gt; 1 T02  
#&gt; 2 M01  
#&gt; 3 M02  
#&gt; 4 M04</code></pre>
<p>前面给出的3个表格有共同的<code>id</code>列，可惜R里面内置函数只能一次合并2个数据框：</p>
<pre class="r"><code>product_full = merge(product_table, product_tests, by = &quot;id&quot;)
product_full
#&gt;    id      name  type   class released material size weight quality
#&gt; 1 M01     JeepX model vehicle      yes Plastics   50     NA       6
#&gt; 2 M02 AircraftX model vehicle      yes Plastics   85    3.0       6
#&gt; 3 M03    Runner model  people      yes     Wood   15     NA       5
#&gt; 4 M04    Dancer model  people       no     Wood   16    0.6       6
#&gt; 5 T01    SupCar   toy vehicle      yes    Metal  120   10.0      NA
#&gt; 6 T02  SupPlane   toy vehicle       no    Metal  350   45.0      10
#&gt;   durability waterproof
#&gt; 1          4        yes
#&gt; 2          5        yes
#&gt; 3         NA        yes
#&gt; 4          6        yes
#&gt; 5         10         no
#&gt; 6          9         no</code></pre>
<p>对完全合并好的表格，我们利用<code>tapply()</code>函数（<code>apply</code>家族成员）可以进行统计，该函数专门用于处理表格数据，使用某些方法根据某列队另一列的数据进行统计。</p>
<p>例如根据type列计算quality列的均值：</p>
<pre class="r"><code>mean_quality1 = tapply(product_full$quality,
                       list(product_full$type),
                       mean, na.rm=TRUE)
mean_quality1
#&gt; model   toy 
#&gt;  5.75 10.00</code></pre>
<p>返回的结果看起来是个数值向量，我们使用<code>str()</code>看看：</p>
<pre class="r"><code>str(mean_quality1)
#&gt;  num [1:2(1d)] 5.75 10
#&gt;  - attr(*, &quot;dimnames&quot;)=List of 1
#&gt;   ..$ : chr [1:2] &quot;model&quot; &quot;toy&quot;</code></pre>
<p><strong>实际上，这是个一维数组</strong>：</p>
<pre class="r"><code>is.array(mean_quality1)
#&gt; [1] TRUE</code></pre>
<p><code>tapply()</code>返回的是一个数组，而不是简单的数值向量，因此可以方便地计算多组操作。</p>
<p>例如计算每一对<code>type</code>和<code>class</code>组合的<code>quality</code>均值：</p>
<pre class="r"><code>mean_quality2 = tapply(product_full$quality,
                       list(product_full$type, product_full$class),
                       mean, na.rm = TRUE)
mean_quality2
#&gt;       people vehicle
#&gt; model    5.5       6
#&gt; toy       NA      10</code></pre>
<p>对于二维数组，我们可以使用两个参数来获取其中的值：</p>
<pre class="r"><code>typeof(mean_quality2)
#&gt; [1] &quot;double&quot;
class(mean_quality2)
#&gt; [1] &quot;matrix&quot;

mean_quality2[&quot;model&quot;, &quot;vehicle&quot;]
#&gt; [1] 6</code></pre>
<p>同理我们可以根据多列分组，使用<code>with()</code>可以避免反复输入<code>product_full</code>：</p>
<pre class="r"><code>mean_quality3 = with(product_full,
                     tapply(quality, list(type, material, released),
                            mean, na.rm = TRUE))

mean_quality3
#&gt; , , no
#&gt; 
#&gt;       Metal Plastics Wood
#&gt; model    NA       NA    6
#&gt; toy      10       NA   NA
#&gt; 
#&gt; , , yes
#&gt; 
#&gt;       Metal Plastics Wood
#&gt; model    NA        6    5
#&gt; toy     NaN       NA   NA</code></pre>
<p>使用3个参数可以获取单元格中的值：</p>
<pre class="r"><code>mean_quality3[&quot;model&quot;, &quot;Wood&quot;, &quot;yes&quot;]
#&gt; [1] 5</code></pre>
</div>
<div id="reshape2" class="section level3">
<h3>reshape2重塑数据框</h3>
<p>前面我们学习了如何筛选、排序、合并和汇总数据框，有时候我们需要做些更复杂的操作。</p>
<p>例如下面数据包含两种产品不同日期的质量和耐久性的测试结果：</p>
<pre class="r"><code>toy_tests = read_csv(&quot;../../R/dataset/product-toy-tests.csv&quot;)
#&gt; Parsed with column specification:
#&gt; cols(
#&gt;   id = col_character(),
#&gt;   date = col_integer(),
#&gt;   sample = col_integer(),
#&gt;   quality = col_integer(),
#&gt;   durability = col_integer()
#&gt; )
toy_tests
#&gt; # A tibble: 8 x 5
#&gt;   id        date sample quality durability
#&gt;   &lt;chr&gt;    &lt;int&gt;  &lt;int&gt;   &lt;int&gt;      &lt;int&gt;
#&gt; 1 T01   20160201    100       9          9
#&gt; 2 T01   20160302    150      10          9
#&gt; 3 T01   20160405    180       9         10
#&gt; 4 T01   20160502    140       9          9
#&gt; 5 T02   20160201     70       7          9
#&gt; 6 T02   20160303     75       8          8
#&gt; 7 T02   20160403     90       9          8
#&gt; 8 T02   20160502     85      10          9</code></pre>
<p>如果需要同时比较两种产品的质量和耐久性，这种格式就比较麻烦，如果是下面的格式就好了：</p>
<pre><code>date    T01 T02
20160201    9   9
2016    10  9</code></pre>
<p><code>reshape2</code>包就是用来搞定这种任务的，如果没有安装，运行下面代码：</p>
<pre class="r"><code>install.packages(&quot;reshape2&quot;)</code></pre>
<p>安装成功后，我们就可以使用<code>dcast()</code>来转换数据，用于比较：</p>
<pre class="r"><code>library(reshape2)

toy_quality = dcast(toy_tests, date ~ id, value.var = &quot;quality&quot;)
toy_quality
#&gt;       date T01 T02
#&gt; 1 20160201   9   7
#&gt; 2 20160302  10  NA
#&gt; 3 20160303  NA   8
#&gt; 4 20160403  NA   9
#&gt; 5 20160405   9  NA
#&gt; 6 20160502   9  10</code></pre>
<p>上述代码重塑了<code>toy_tests</code>让<code>date</code>列被共享，<code>id</code>值被单独分割为列，每个<code>date</code>与<code>id</code>对应的值是<code>quality</code>。</p>
<p>可以看到数据中存在缺失值，有一种叫<strong>末次观测值结转法（LOCF）</strong>可以填补缺失值，当非缺失值后面紧跟一个缺失值时，就用该缺失值填补后面的缺失值，直到所有缺失值都被填满。<code>zoo</code>包提供了LOCF的一个实现，使用下面代码安装：</p>
<pre class="r"><code>install.packages(&quot;zoo&quot;)</code></pre>
<p>下面用一组简单的向量演示：</p>
<pre class="r"><code>library(zoo)
#&gt; 
#&gt; 载入程辑包：&#39;zoo&#39;
#&gt; The following objects are masked from &#39;package:base&#39;:
#&gt; 
#&gt;     as.Date, as.Date.numeric
na.locf(c(1, 2, NA, NA, 3, 1, NA, 2, NA))
#&gt; [1] 1 2 2 2 3 1 1 2 2</code></pre>
<p>同样的方法我们可以应用于现在处理的数据：</p>
<pre class="r"><code>na.locf(toy_quality$T01)
#&gt; [1]  9 10 10 10  9  9</code></pre>
<p>如果需要填补的数据很多，包含上千个产品，更好的做法是使用<code>lapply</code>进行自动分配：</p>
<pre class="r"><code>toy_quality[-1] = lapply(toy_quality[-1], na.locf )
toy_quality
#&gt;       date T01 T02
#&gt; 1 20160201   9   7
#&gt; 2 20160302  10   7
#&gt; 3 20160303  10   8
#&gt; 4 20160403  10   9
#&gt; 5 20160405   9   9
#&gt; 6 20160502   9  10</code></pre>
<p>这里数据虽然已经没有了缺失值，但每一行数据的含义却发生了变化。原始数据中产品T01在20160303这天并没有测试，所以这一天的值应该被解释为在此之前的最后一次quality的测试值。另一个问题是两种产品都是按月测试的，但重塑后的数据框没有以固定的频率对其date。</p>
<p>下面方法进问题进行修正。</p>
<pre class="r"><code>toy_tests$ym = substr(toy_tests$date, 1, 6)
toy_tests
#&gt; # A tibble: 8 x 6
#&gt;   id        date sample quality durability ym    
#&gt;   &lt;chr&gt;    &lt;int&gt;  &lt;int&gt;   &lt;int&gt;      &lt;int&gt; &lt;chr&gt; 
#&gt; 1 T01   20160201    100       9          9 201602
#&gt; 2 T01   20160302    150      10          9 201603
#&gt; 3 T01   20160405    180       9         10 201604
#&gt; 4 T01   20160502    140       9          9 201605
#&gt; 5 T02   20160201     70       7          9 201602
#&gt; 6 T02   20160303     75       8          8 201603
#&gt; 7 T02   20160403     90       9          8 201604
#&gt; 8 T02   20160502     85      10          9 201605</code></pre>
<p>我们只提取年月信息，然后利用它进行重塑。</p>
<pre class="r"><code>toy_quality = dcast(toy_tests, ym ~ id, value.var = &quot;quality&quot;)
toy_quality
#&gt;       ym T01 T02
#&gt; 1 201602   9   7
#&gt; 2 201603  10   8
#&gt; 3 201604   9   9
#&gt; 4 201605   9  10</code></pre>
<p>现在，两种产品每月的质量得分自然地展示出来，而且每月缺失值。</p>
<p>有时候，我们需要将<strong>许多列合并为1列</strong>，用于表示被测量的对象，另外用1列存储对应的结果值。下面用<code>melt()</code>函数将原始数据两种测量组合到一起：</p>
<pre class="r"><code>toy_tests2 = melt(toy_tests, id.vars = c(&quot;id&quot;, &quot;ym&quot;), 
                  measure.vars = c(&quot;quality&quot;, &quot;durability&quot;),
                  variable.name = &quot;measure&quot;)
toy_tests2
#&gt;     id     ym    measure value
#&gt; 1  T01 201602    quality     9
#&gt; 2  T01 201603    quality    10
#&gt; 3  T01 201604    quality     9
#&gt; 4  T01 201605    quality     9
#&gt; 5  T02 201602    quality     7
#&gt; 6  T02 201603    quality     8
#&gt; 7  T02 201604    quality     9
#&gt; 8  T02 201605    quality    10
#&gt; 9  T01 201602 durability     9
#&gt; 10 T01 201603 durability     9
#&gt; 11 T01 201604 durability    10
#&gt; 12 T01 201605 durability     9
#&gt; 13 T02 201602 durability     9
#&gt; 14 T02 201603 durability     8
#&gt; 15 T02 201604 durability     8
#&gt; 16 T02 201605 durability     9</code></pre>
<p>这种格式正是<code>ggplot2</code>所喜爱的长格式数据，我们可以来画图：</p>
<pre class="r"><code>library(ggplot2)

ggplot(toy_tests2, aes(x = ym, y = value)) + 
    geom_point() + 
    facet_grid(id ~ measure)</code></pre>
<p><img src="/post/2018-08-25-r-operate-data_files/figure-html/unnamed-chunk-38-1.png" width="672" /></p>
<p>我们得到了按照产品id和measure分组，以ym为x轴，以value为y轴的散点图，可以清晰对比分组后两种产品质量差异（以年月）。</p>
<p>我们还可以用不同的颜色来表示产品，下图可以给出与上图相同的信息：</p>
<pre class="r"><code>ggplot(toy_tests2, aes(x = ym, y = value, color = id)) + 
    geom_point() + facet_grid(. ~ measure)</code></pre>
<p><img src="/post/2018-08-25-r-operate-data_files/figure-html/unnamed-chunk-39-1.png" width="672" /></p>
</div>
</div>
<div id="sqldfsql" class="section level2">
<h2>通过sqldf包使用SQL查询数据框</h2>
<p>有没有一种方法，能够直接使用SQL进行数据框查询，就像数据框是关系型数据库中的表一样呢？<code>sqldf</code>包给出肯定答案。该包吸收了SQLite轻量结构和易于嵌入R会话的优点，可以用下面代码安装：</p>
<pre class="r"><code>install.packages(&quot;sqldf&quot;)</code></pre>
<p>首先加载包：</p>
<pre class="r"><code>library(sqldf)
#&gt; 载入需要的程辑包：gsubfn
#&gt; 载入需要的程辑包：proto
#&gt; 载入需要的程辑包：RSQLite</code></pre>
<p>注意加载<code>sqldf</code>包时，几个依赖包会自动加载进来。<strong><code>sql</code>包的实现依赖这些包，它基本上是在R和SQLite之间传输数据和转换数据类型</strong>。</p>
<p>读入前面使用的产品表格：</p>
<pre class="r"><code>product_info = read_csv(&quot;../../R/dataset/product-info.csv&quot;)
#&gt; Parsed with column specification:
#&gt; cols(
#&gt;   id = col_character(),
#&gt;   name = col_character(),
#&gt;   type = col_character(),
#&gt;   class = col_character(),
#&gt;   released = col_character()
#&gt; )
product_stats = read_csv(&quot;../../R/dataset/product-stats.csv&quot;)
#&gt; Parsed with column specification:
#&gt; cols(
#&gt;   id = col_character(),
#&gt;   material = col_character(),
#&gt;   size = col_integer(),
#&gt;   weight = col_double()
#&gt; )
product_tests = read_csv(&quot;../../R/dataset/product-tests.csv&quot;)
#&gt; Parsed with column specification:
#&gt; cols(
#&gt;   id = col_character(),
#&gt;   quality = col_integer(),
#&gt;   durability = col_integer(),
#&gt;   waterproof = col_character()
#&gt; )
toy_tests = read_csv(&quot;../../R/dataset/product-toy-tests.csv&quot;)
#&gt; Parsed with column specification:
#&gt; cols(
#&gt;   id = col_character(),
#&gt;   date = col_integer(),
#&gt;   sample = col_integer(),
#&gt;   quality = col_integer(),
#&gt;   durability = col_integer()
#&gt; )</code></pre>
<p><code>sqldf</code>包的神奇之处在于我们可以使用SQL语句查询工作环境中的数据框，例如：</p>
<pre class="r"><code>sqldf(&quot;select * from product_info&quot;)
#&gt;    id      name  type   class released
#&gt; 1 T01    SupCar   toy vehicle      yes
#&gt; 2 T02  SupPlane   toy vehicle       no
#&gt; 3 M01     JeepX model vehicle      yes
#&gt; 4 M02 AircraftX model vehicle      yes
#&gt; 5 M03    Runner model  people      yes
#&gt; 6 M04    Dancer model  people       no</code></pre>
<p>sqldf与SQLite一样，支持简单的选择性请求。</p>
<p>比如选择特定列：</p>
<pre class="r"><code>sqldf(&quot;select id, name, class from product_info&quot;)
#&gt;    id      name   class
#&gt; 1 T01    SupCar vehicle
#&gt; 2 T02  SupPlane vehicle
#&gt; 3 M01     JeepX vehicle
#&gt; 4 M02 AircraftX vehicle
#&gt; 5 M03    Runner  people
#&gt; 6 M04    Dancer  people</code></pre>
<p>根据条件筛选记录：</p>
<pre class="r"><code>sqldf(&quot;select id, name from product_info where released = &#39;yes&#39; &quot;)
#&gt;    id      name
#&gt; 1 T01    SupCar
#&gt; 2 M01     JeepX
#&gt; 3 M02 AircraftX
#&gt; 4 M03    Runner</code></pre>
<p>除了基本的数据库操作和分组统计，该包还支持查询多个数据框，比如：</p>
<pre class="r"><code>sqldf(&quot;select * from product_info join product_stats using (id)&quot;)
#&gt;    id      name  type   class released material size weight
#&gt; 1 T01    SupCar   toy vehicle      yes    Metal  120   10.0
#&gt; 2 T02  SupPlane   toy vehicle       no    Metal  350   45.0
#&gt; 3 M01     JeepX model vehicle      yes Plastics   50     NA
#&gt; 4 M02 AircraftX model vehicle      yes Plastics   85    3.0
#&gt; 5 M03    Runner model  people      yes     Wood   15     NA
#&gt; 6 M04    Dancer model  people       no     Wood   16    0.6</code></pre>
<p>不过sqldf包的缺点也很明显：</p>
<ol style="list-style-type: decimal">
<li>sqldf默认基于SQLite，因此SQLite的局限性就是该包的局限性，比如内置的分组汇总函数是有限的，而R本身的统计汇总函数要多得多</li>
<li>不方便动态编程</li>
<li>SQL的限制性也限制了该包，我们难以像操作dplyr包一样用sqldf进行表格数据的操作、变换等等</li>
</ol>
<blockquote>
<p>如果你喜欢这个包并想用起来，阅读sqldf更多操作例子：<a href="https://github.com/ggrothendieck/sqldf#examples" class="uri">https://github.com/ggrothendieck/sqldf#examples</a></p>
</blockquote>
</div>
<div id="data.table" class="section level2">
<h2>使用data.table包操作数据</h2>
<p><strong><code>data.table</code>包提供了一个加强版的<code>data.frame</code>，它运行效率极高，而且能够处理适合内存的大数据集，它使用<code>[]</code>实现了一种自然地数据操作语法</strong>。使用下面命令进行安装：</p>
<pre class="r"><code>install.packages(&quot;data.table&quot;)</code></pre>
<p>载入包：</p>
<pre class="r"><code>library(data.table)
#&gt; 
#&gt; 载入程辑包：&#39;data.table&#39;
#&gt; The following objects are masked from &#39;package:reshape2&#39;:
#&gt; 
#&gt;     dcast, melt</code></pre>
<p>注意，<code>data.table</code>包提供了加强版的<code>dcast()</code>和<code>melt()</code>，它们的功能更强大、性能更高，内存使用也更高效。</p>
<p>创建<code>data.table</code>与创建<code>data.frame</code>类似：</p>
<pre class="r"><code>dt = data.table(x = 1:3, y = rnorm(3), z = letters[1:3])
dt
#&gt;    x      y z
#&gt; 1: 1 -0.824 a
#&gt; 2: 2 -0.743 b
#&gt; 3: 3  0.560 c</code></pre>
<p>检查它的结构：</p>
<pre class="r"><code>str(dt)
#&gt; Classes &#39;data.table&#39; and &#39;data.frame&#39;:   3 obs. of  3 variables:
#&gt;  $ x: int  1 2 3
#&gt;  $ y: num  -0.824 -0.743 0.56
#&gt;  $ z: chr  &quot;a&quot; &quot;b&quot; &quot;c&quot;
#&gt;  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;</code></pre>
<p>可以看到，<code>dt</code>的类是<code>data.table</code>和<code>data.frame</code>，也就是说<code>data.table</code>继承了<code>data.frame</code>的一些行为，但增强了其他部分。</p>
<p>**<code>data.table</code>的基本语法是<code>dt[i, j, by]，简单说就是使用</code>i<code>选择行，用</code>by<code>分组，然后计算</code>j<code>。**接下来我们看看</code>data.table`继承了什么，增强了什么。</p>
<p>首先，我们仍然载入之前用到的产品数据，不过这里我们使用<code>data.table</code>包提供的<code>fread()</code>函数，它非常高效和智能，默认返回<code>data.table</code>。</p>
<pre class="r"><code>product_info = fread(&quot;../../R/dataset/product-info.csv&quot;)
product_stats = fread(&quot;../../R/dataset/product-stats.csv&quot;)
product_tests = fread(&quot;../../R/dataset/product-tests.csv&quot;)
toy_tests = fread(&quot;../../R/dataset/product-toy-tests.csv&quot;)</code></pre>
<p>如果查看表格信息，你会发现它和<code>data.frame</code>没什么两样：</p>
<pre class="r"><code>product_info
#&gt;     id      name  type   class released
#&gt; 1: T01    SupCar   toy vehicle      yes
#&gt; 2: T02  SupPlane   toy vehicle       no
#&gt; 3: M01     JeepX model vehicle      yes
#&gt; 4: M02 AircraftX model vehicle      yes
#&gt; 5: M03    Runner model  people      yes
#&gt; 6: M04    Dancer model  people       no</code></pre>
<p>再看结构：</p>
<pre class="r"><code>str(product_info)
#&gt; Classes &#39;data.table&#39; and &#39;data.frame&#39;:   6 obs. of  5 variables:
#&gt;  $ id      : chr  &quot;T01&quot; &quot;T02&quot; &quot;M01&quot; &quot;M02&quot; ...
#&gt;  $ name    : chr  &quot;SupCar&quot; &quot;SupPlane&quot; &quot;JeepX&quot; &quot;AircraftX&quot; ...
#&gt;  $ type    : chr  &quot;toy&quot; &quot;toy&quot; &quot;model&quot; &quot;model&quot; ...
#&gt;  $ class   : chr  &quot;vehicle&quot; &quot;vehicle&quot; &quot;vehicle&quot; &quot;vehicle&quot; ...
#&gt;  $ released: chr  &quot;yes&quot; &quot;no&quot; &quot;yes&quot; &quot;yes&quot; ...
#&gt;  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;</code></pre>
<p>与<code>data.frame</code>不同，如果只提供一个参数用来构建子集，<code>data.table</code>是选择行而不是列：</p>
<pre class="r"><code>product_info[1]
#&gt;     id   name type   class released
#&gt; 1: T01 SupCar  toy vehicle      yes

product_info[1:3]
#&gt;     id     name  type   class released
#&gt; 1: T01   SupCar   toy vehicle      yes
#&gt; 2: T02 SupPlane   toy vehicle       no
#&gt; 3: M01    JeepX model vehicle      yes</code></pre>
<p>如果提供的是负数，那么将删除指定的行：</p>
<pre class="r"><code>product_info[-1]
#&gt;     id      name  type   class released
#&gt; 1: T02  SupPlane   toy vehicle       no
#&gt; 2: M01     JeepX model vehicle      yes
#&gt; 3: M02 AircraftX model vehicle      yes
#&gt; 4: M03    Runner model  people      yes
#&gt; 5: M04    Dancer model  people       no</code></pre>
<p><strong>data.table提供了许多特殊符号，它们是data.table的重要组成</strong>。<code>.N</code>是最常用的符号之一，它表示当前分组中，对象的数目（就不用调用<code>nrow</code>函数啦）。在<code>[]</code>使用它指提取最后一行。</p>
<pre class="r"><code>product_info[.N]
#&gt;     id   name  type  class released
#&gt; 1: M04 Dancer model people       no</code></pre>
<pre class="r"><code>product_info[c(1, .N)]
#&gt;     id   name  type   class released
#&gt; 1: T01 SupCar   toy vehicle      yes
#&gt; 2: M04 Dancer model  people       no</code></pre>
<p>在对<code>data.table</code>构建子集时，能够自动根据语义计算表达式，因此可以直接使用列名，像<code>with()</code>和<code>subset()</code>那样。</p>
<p>比如：</p>
<pre class="r"><code>product_info[released == &quot;yes&quot;]
#&gt;     id      name  type   class released
#&gt; 1: T01    SupCar   toy vehicle      yes
#&gt; 2: M01     JeepX model vehicle      yes
#&gt; 3: M02 AircraftX model vehicle      yes
#&gt; 4: M03    Runner model  people      yes</code></pre>
<p>方括号内的第1个参数是行筛选器，第2个则对筛选后的数据进行适当的计算。</p>
<p>例如提取列：</p>
<pre class="r"><code>product_info[released == &quot;yes&quot;, id]
#&gt; [1] &quot;T01&quot; &quot;M01&quot; &quot;M02&quot; &quot;M03&quot;</code></pre>
<p>在这里使用<code>&quot;id&quot;</code>结果不同，返回的必然是个data.table。</p>
<pre class="r"><code>product_info[released == &quot;yes&quot;, &quot;id&quot;]
#&gt;     id
#&gt; 1: T01
#&gt; 2: M01
#&gt; 3: M02
#&gt; 4: M03</code></pre>
<p>第二个参数可以是表达式，例如生成一张表，反应每种<code>type</code>和<code>class</code>组合中<code>released</code>取<code>yes</code>的数量：</p>
<pre class="r"><code>product_info[released == &quot;yes&quot;, table(type, class)]
#&gt;        class
#&gt; type    people vehicle
#&gt;   model      1       2
#&gt;   toy        0       1</code></pre>
<p><strong>要注意，给第2个参数提供<code>list()</code>，结果仍然转换为<code>data.table</code></strong>：</p>
<pre class="r"><code>product_info[released == &quot;yes&quot;, list(id, name)]
#&gt;     id      name
#&gt; 1: T01    SupCar
#&gt; 2: M01     JeepX
#&gt; 3: M02 AircraftX
#&gt; 4: M03    Runner</code></pre>
<p>我们可以替换原有列，生成新的data.table：</p>
<pre class="r"><code>product_info[, list(id, name, released = released == &quot;yes&quot;)]
#&gt;     id      name released
#&gt; 1: T01    SupCar     TRUE
#&gt; 2: T02  SupPlane    FALSE
#&gt; 3: M01     JeepX     TRUE
#&gt; 4: M02 AircraftX     TRUE
#&gt; 5: M03    Runner     TRUE
#&gt; 6: M04    Dancer    FALSE</code></pre>
<p>还可以创建新列：</p>
<pre class="r"><code>product_stats[, list(id, material, size, weight, density = size/weight)]
#&gt;     id material size weight density
#&gt; 1: T01    Metal  120   10.0   12.00
#&gt; 2: T02    Metal  350   45.0    7.78
#&gt; 3: M01 Plastics   50     NA      NA
#&gt; 4: M02 Plastics   85    3.0   28.33
#&gt; 5: M03     Wood   15     NA      NA
#&gt; 6: M04     Wood   16    0.6   26.67</code></pre>
<p><strong>为了简化，data.table使用<code>.()</code>作为<code>list()</code>的缩写，这两者等价</strong>：</p>
<pre class="r"><code>product_info[, .(id, name, type, class)]
#&gt;     id      name  type   class
#&gt; 1: T01    SupCar   toy vehicle
#&gt; 2: T02  SupPlane   toy vehicle
#&gt; 3: M01     JeepX model vehicle
#&gt; 4: M02 AircraftX model vehicle
#&gt; 5: M03    Runner model  people
#&gt; 6: M04    Dancer model  people

product_info[released == &quot;yes&quot;, .(id, name)]
#&gt;     id      name
#&gt; 1: T01    SupCar
#&gt; 2: M01     JeepX
#&gt; 3: M02 AircraftX
#&gt; 4: M03    Runner</code></pre>
<p>提供排序索引可以对记录排序：</p>
<pre class="r"><code>product_stats[order(size, decreasing = TRUE)]
#&gt;     id material size weight
#&gt; 1: T02    Metal  350   45.0
#&gt; 2: T01    Metal  120   10.0
#&gt; 3: M02 Plastics   85    3.0
#&gt; 4: M01 Plastics   50     NA
#&gt; 5: M04     Wood   16    0.6
#&gt; 6: M03     Wood   15     NA</code></pre>
<p><strong>前面都是在构建子集后，又创建新的data.table</strong>。这样挺麻烦的，因此<code>data.table</code>包提供了对列进行原地赋值的符号<code>:=</code>，例如<code>product_stats</code>开始是这样的：</p>
<pre class="r"><code>product_stats
#&gt;     id material size weight
#&gt; 1: T01    Metal  120   10.0
#&gt; 2: T02    Metal  350   45.0
#&gt; 3: M01 Plastics   50     NA
#&gt; 4: M02 Plastics   85    3.0
#&gt; 5: M03     Wood   15     NA
#&gt; 6: M04     Wood   16    0.6</code></pre>
<p>使用<code>:=</code>直接在上面数据框创建新列：</p>
<pre class="r"><code>product_stats[, density := size / weight]</code></pre>
<p>虽然没有任何返回，但数据已经被修改了：</p>
<pre class="r"><code>product_stats
#&gt;     id material size weight density
#&gt; 1: T01    Metal  120   10.0   12.00
#&gt; 2: T02    Metal  350   45.0    7.78
#&gt; 3: M01 Plastics   50     NA      NA
#&gt; 4: M02 Plastics   85    3.0   28.33
#&gt; 5: M03     Wood   15     NA      NA
#&gt; 6: M04     Wood   16    0.6   26.67</code></pre>
<p>使用<code>:=</code>替换已有的列：</p>
<pre class="r"><code>product_info[, released := released == &quot;yes&quot;]
product_info
#&gt;     id      name  type   class released
#&gt; 1: T01    SupCar   toy vehicle     TRUE
#&gt; 2: T02  SupPlane   toy vehicle    FALSE
#&gt; 3: M01     JeepX model vehicle     TRUE
#&gt; 4: M02 AircraftX model vehicle     TRUE
#&gt; 5: M03    Runner model  people     TRUE
#&gt; 6: M04    Dancer model  people    FALSE</code></pre>
<div class="section level3">
<h3>使用键获取值</h3>
<p><strong>索引支持</strong>是data.table另一个独特功能，即我们可以创建键（key），使用键获取记录及其高效。</p>
<p>例如，使用<code>setkey()</code>将<code>id</code>设置为<code>product_info</code>中的一个键：</p>
<pre class="r"><code>setkey(product_info, id)</code></pre>
<p>同样的，函数无任何返回，但我们已经为原始数据设置了键，而且原来的数据看起来也没变化：</p>
<pre class="r"><code>product_info
#&gt;     id      name  type   class released
#&gt; 1: M01     JeepX model vehicle     TRUE
#&gt; 2: M02 AircraftX model vehicle     TRUE
#&gt; 3: M03    Runner model  people     TRUE
#&gt; 4: M04    Dancer model  people    FALSE
#&gt; 5: T01    SupCar   toy vehicle     TRUE
#&gt; 6: T02  SupPlane   toy vehicle    FALSE</code></pre>
<p>但键已生成：</p>
<pre class="r"><code>key(product_info)
#&gt; [1] &quot;id&quot;</code></pre>
<p>现在我们可以用它来获取数据了，比如提供一个id值：</p>
<pre class="r"><code>product_info[&quot;M01&quot;]
#&gt;     id  name  type   class released
#&gt; 1: M01 JeepX model vehicle     TRUE</code></pre>
<p>也可以使用<code>setkeyv()</code>来设置键，但它只接受字符向量：</p>
<pre class="r"><code>setkeyv(product_stats, &quot;id&quot;)</code></pre>
<p><strong>当<code>key</code>是一个动态变化的向量时，这个函数会非常好用</strong>。</p>
<pre class="r"><code>product_stats[&quot;M02&quot;]
#&gt;     id material size weight density
#&gt; 1: M02 Plastics   85      3    28.3</code></pre>
<p>如果两个表格有相同的键，我们可以轻松把他们连接到一起：</p>
<pre class="r"><code>product_info[product_stats]
#&gt;     id      name  type   class released material size weight density
#&gt; 1: M01     JeepX model vehicle     TRUE Plastics   50     NA      NA
#&gt; 2: M02 AircraftX model vehicle     TRUE Plastics   85    3.0   28.33
#&gt; 3: M03    Runner model  people     TRUE     Wood   15     NA      NA
#&gt; 4: M04    Dancer model  people    FALSE     Wood   16    0.6   26.67
#&gt; 5: T01    SupCar   toy vehicle     TRUE    Metal  120   10.0   12.00
#&gt; 6: T02  SupPlane   toy vehicle    FALSE    Metal  350   45.0    7.78</code></pre>
<p><strong>data.table的键可以不止一个</strong>。例如使用<code>id</code>和<code>date</code>定位<code>toy_tests</code>中的记录：</p>
<pre class="r"><code>setkey(toy_tests, id, date)</code></pre>
<p>现在提供key中的两个元素就可以获取记录了</p>
<pre class="r"><code>toy_tests[.(&quot;T01&quot;, 20160201)]
#&gt;     id     date sample quality durability
#&gt; 1: T01 20160201    100       9          9</code></pre>
<p>如果提供第一个元素，会返回匹配的多个值：</p>
<pre class="r"><code>toy_tests[&quot;T01&quot;]
#&gt;     id     date sample quality durability
#&gt; 1: T01 20160201    100       9          9
#&gt; 2: T01 20160302    150      10          9
#&gt; 3: T01 20160405    180       9         10
#&gt; 4: T01 20160502    140       9          9</code></pre>
<p>key不能错序，因此不能单独提供第2个元素以及反序排列。</p>
<pre class="r"><code>toy_tests[20160201]
#&gt;      id date sample quality durability
#&gt; 1: &lt;NA&gt;   NA     NA      NA         NA

toy_tests[.(20160202,&quot;T01&quot;)]
#&gt; Error in bmerge(i, x, leftcols, rightcols, io, xo, roll, rollends, nomatch, : x.&#39;id&#39; is a character column being joined to i.&#39;V1&#39; which is type &#39;double&#39;. Character columns must join to factor or character columns.</code></pre>
</div>
<div class="section level3">
<h3>对数据分组汇总</h3>
</div>
</div>
