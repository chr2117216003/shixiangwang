---
title: "R-操作数据库"
author: 王诗翔
date: 2018-08-19
slug: "r-operate-database"
categories: 
    - R
tags:
    - SQL
    - SQLite
    - MySQL
    - MongoDB
    - Redis
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE, dev = "png", comment = "#>")
#Sys.setlocale('LC_ALL','C') # Embed this directly in the Rmarkdown script that contains the Chinese character comment
options(digits=3)
options(max.print=200)
```

>内容：
>
>* 了解关系型数据库
>* 使用SQL工具
>* 操作非关系型数据库

使用数据库能够有效地应对超出计算机内存容量的数据存储问题，还可以根据用户提供的条件，对数据库中的数据进行查询，这也使在数据库中更新现有记录和插入新数据的操作变得简单。

## 操作关系型数据库

**关系型数据库就是一个由表和表之间的关系组成的集合。数据库中的表和R中的数据框有相同地形式。表之间可以互相关联，让我们能够轻松合并多张表信息。**

下面从最简单数据库开始，**SQLite（<http://sqlite.org/>）**是一个轻量级的数据库引擎。

在R中操作SQLite数据库需要用RSQLite扩展包。运行下面代码：

```{r}
if(!require("RSQLite")) install.packages("RSQLite")
```

### 创建SQLite数据库

现在在博客R目录下创建一个data目录，用来存储数据库：

```{r}
if (!dir.exists("../../R/data")) dir.create("../../R/data")
```

接下来载入`RSQLite`包，提供数据库驱动`SQLite()`和数据库文件`example.sqlite`建立连接。如果目标文件不存在，数据库驱动会创建一个新的空文件，即空SQLite数据库：

```{r}
library(RSQLite)

con = dbConnect(SQLite(), "../../R/data/example.sqlite")
```

**数据库连接`con`是介于用户和系统中间的一层。我们可以创建一个连接，并且连接到关系型数据库，并通过这个连接实现查询、抽取以及更新数据。**后续将一直使用这个连接，直到这个连接被关闭。

我们可以在关系数据库中创建新表，表看起来和R里的数据框是一样的。

下面创建一个数据框，并将它作为表插入数据库中。

```{r}
example1 = data.frame(
    id = 1:5,
    type = c("A", "A", "B", "B", "C"),
    score = c(8, 9, 8, 10, 9),
    stringsAsFactors = FALSE
)

example1
```

现在进行写入：

```{r}
dbWriteTable(con, "example1", example1, overwrite = TRUE)
```

接下来使用`dbDisconnect()`断开数据库连接，这样`con`便不可用了。

```{r}
dbDisconnect(con)
```

#### 向一个数据库写入多张表格

现在我们将`ggplot2`的`diamonds`数据集和`nycflights13`中的`flights`数据集作为两张表格写入数据库中。

```{r}
if(!require("ggplot2")) install.packages("ggplot2")

if(!require("nycflights13")) install.packages("nycflights13")

data("diamonds", package = "ggplot2")
data("flights", package = "nycflights13")
```

我们重复之前的操作流程：

```{r, error=TRUE}
con = dbConnect(SQLite(), "../../R/data/datasets.sqlite")
dbWriteTable(con, "diamonds", diamonds, row.names = FALSE, overwrite = TRUE)
dbWriteTable(con, "flights", flights, row.names = FALSE, overwrite = TRUE)
dbDisconnect(con)
```

这里使用`overwrite=TRUE`的目的是防止多次添加同一张表报错。

现在数据库中有两张表了。

#### 向表中追加数据

下面先生成几个数据块，然后增加到数据库的表中：

```{r}
con = dbConnect(SQLite(), "../../R/data/example2.sqlite")

chunk_size = 10
id = 0
for (i in 1:6){
    chunk = data.frame(id = ((i - 1L) * chunk_size):(i * chunk_size -1L),
                       type = LETTERS[[i]],
                       score = rbinom(chunk_size, 10, (10-i)/10),
                       stringsAsFactors = FALSE)
    dbWriteTable(con, "products", chunk,
                 append = i > 1, row.names = FALSE)
}

dbDisconnect(con)
```

每次代码块都生成一个数据框，包含一些确定数据和随机数，我们将这些数据记录追加到一个名为`products`的表中。

### 访问表和表中字段

当有了数据库和数据，我们可以进行数据访问。比如所有表的名字或某个表的列。

```{r}
con = dbConnect(SQLite(), "../../R/data/datasets.sqlite")
```

使用`dbExistsTable()`可以检查数据库是否存在某张表：

```{r}
dbExistsTable(con, "diamonds")

dbExistsTable(con, "mtcars")
```

下面列出该数据库的所有表：

```{r}
dbListTables(con)
```

对于某一张表，我们可以使用`dbListFields()`列出表的列名（或字段）：

```{r}
dbListFields(con, "diamonds")
```

与`dbWriteTable()`相反，`adReadTable()`将表格读入为数据框：

```{r}
db.diamonds = dbReadTable(con, "diamonds")
dbDisconnect(con)

head(db.diamonds)
str(db.diamonds)
```

### 用SQL对关系数据库进行查询

这部分我们学习如何根据需求对数据库进行查询，进而从中获取数据。SQL是重点，中文叫结构化查询语句。